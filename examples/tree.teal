// An implementation of a binary tree

type Label (v : int);

type Tree(left : Tree, value : nonnull Label, right : Tree);

fun nothing() = { return new Label(null); }

fun empty_tree() = { return new Tree(null, nothing(), null); }

fun tree_add(t : Tree, x : int) = {
    if (t.value.v == nothing()) {
        t.value.v := new Label(x);
        t.left := empty_tree();
        t.right := empty_tree();
    }
    if (t.value.v < x) { tree_add(t.right, x); }
    if (t.value.v > x) { tree_add(t.left, x); }
}

fun tree_add_array(t : Tree, arr : array[int]) = {
    var i := 0;
    var s := array_length(arr);
    while (i < s) {
            i := i + 1;
            tree_add(t, arr[i]);
    }
}

fun tree_contains(t : Tree, x : int) = {
    if (t.value == nothing()) { return 0; }
    if (t.value.v == x.value) { return 1; }
    if (t.value.v < x.value) { return tree_contains(t.right, x); }
    if (t.value.v > x.value) { return tree_contains(t.left, x); }
}

fun union(other : Tree) = {
    // TODO
}

fun intersection(other : Tree) = {
    // TODO
}

fun remove_duplicates(arr : array[int]) = {
    // A function that will replace duplicates in an array
    // With the value null.

    // In this we save what we have seen so far.
    var s : Tree := empty_tree();
    var i := 0;
    var l := array_length(arr);
    while (i < l) {
          var e : int := arr[i];
          if (tree_contains(s, e)) {
             arr[i] := null;
          } else {
            tree_add(s, e);
          } 
          i := i + 1;
    } 
    return arr;
}

fun main() = {
    var t : Tree := empty_tree();
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add_array(t, [6, 7, 8]);

    print(tree_contains(t, 0));
    print(tree_contains(t, 2));

    print(tree_contains(t, 4));
    print(tree_contains(t, 5));

    // We test remove_duplicates
    print(remove_duplicates([1, 2, 2, 3, 4, 5]));
}
