// An implementation of a binary tree



type Leaf(dummy : any);
type Branch(left : nonnull any, value : nonnull int, right : nonnull any);
var leaf_singleton;

fun leaf() = {
    if leaf_singleton == null {
        leaf_singleton := new Leaf("");
    }
    return leaf_singleton;
}

type Tree(t : nonnull any);

fun tree_empty() : Tree = return new Tree(leaf());

fun tree_add(t : Tree, x : nonnull int) = {
 t.t := _tree_rec_add(t.t, x);
}

fun _rec_tree_add(node : nonnull any, x : nonnull int) : nonnull any = {
    if node == leaf() {
        return Branch(leaf(), x, leaf());
    }
    // else compare / recurse
}

/////

type TreeBox(content : nonull any);

fun empty_tree() = {
 if (nothing == null) {
  nothing := new Leaf();
 }
 return TreeBox(nothing);
}

fun tree_add(t : TreeBox, x : int) = {
    if (t.content == nothing) {
        t.content := new Tree();
        t.content.value := x; 
        t.content.left := empty_tree();
        t.right := empty_tree();
    }
    if (t.content.value < x) { tree_add(t.right, x); }
    if (t.content.value > x) { tree_add(t.left, x); }
}

fun tree_add_array(t : Tree, arr : array[int]) = {
    var i := 0;
    var s := array_length(arr);
    while (i < s) {
            i := i + 1;
            tree_add(t, arr[i]);
    }
}

fun tree_contains(t : Tree, x : int) = {
    if (t.value == nothing()) { return 0; }
    if (t.value.v == x.value) { return 1; }
    if (t.value.v < x.value) { return tree_contains(t.right, x); }
    if (t.value.v > x.value) { return tree_contains(t.left, x); }
}

fun union(other : Tree) = {
    // TODO
}

fun intersection(other : Tree) = {
    // TODO
}

fun remove_duplicates(arr : array[int]) = {
    // A function that will replace duplicates in an array
    // With the value null.

    // In this we save what we have seen so far.
    var s : Tree := empty_tree();
    var i := 0;
    var l := array_length(arr);
    while (i < l) {
          var e : int := arr[i];
          if (tree_contains(s, e)) {
             arr[i] := null;
          } else {
            tree_add(s, e);
          } 
          i := i + 1;
    } 
    return arr;
}

fun main() = {
    var t : Tree := empty_tree();
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add(t, 2);
    tree_add_array(t, [6, 7, 8]);

    print(tree_contains(t, 0));
    print(tree_contains(t, 2));

    print(tree_contains(t, 4));
    print(tree_contains(t, 5));

    // We test remove_duplicates
    print(remove_duplicates([1, 2, 2, 3, 4, 5]));
}
