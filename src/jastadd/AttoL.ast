// Top level
Program ::= ImportDecl* Decl*;

// ImportDecl
ImportDecl ::= PackagePathFragment* ;
PackagePathFragment ::= <ID>;

// Declarations
abstract Decl;

// Variables
VarDecl : Decl ::= Name:IdDecl [Type] [Initializer:Expr];

// Functions
FunDecl : Decl ::= Name:IdDecl [Type] Formal:VarDecl* [Body:Stmt];

TypeVarDecl ::= IdDecl ;

// Type declarations
TypeDecl : Decl ::= Name:IdDecl TypeFormal:TypeVarDecl* ;
AliasTypeDecl : TypeDecl ::=  Type;
StructTypeDecl : TypeDecl ::= SuperType:Type* StructElt*;
abstract StructElt;
VarDeclElt : StructElt ::= VarDecl;
FunDeclElt : StructElt ::= FunDecl;
// TODO: do we want statements inside structs ?
StmtElt : StructElt ::= Stmt;


// TODO: what are the FunFormal arguments for a class?
// Arguments to the constructor?
// Class declarations
ClassDecl : Decl ::= Name:IdDecl TypeFormal:TypeVarDecl* FunFormal:VarDecl* SuperType:Type* StructElt*;

// Qualifier declarations
QualifierDecl : Decl ::= Name:IdDecl TypeFormal:TypeVarDecl* FunFormal:IdDecl* VarDecl SuperType:Type* StructElt*;


// Type uses
abstract Type;
SimpleType : Type ::= IdUse Actual:Type* ;
TypeQualifier ::= IdUse TypeActual:Type* FunActual:Expr* ;
QualifiedType : Type ::= Type TypeQualifier;

// Expressions
abstract Expr;

// Binary
abstract BinExpr : Expr ::= Left:Expr Right:Expr;
AddExpr : BinExpr;
SubExpr : BinExpr;
MulExpr : BinExpr;
DivExpr : BinExpr;
ModExpr : BinExpr;
EQExpr : BinExpr;
NEQExpr : BinExpr;
LTExpr : BinExpr;
GTExpr : BinExpr;
LEQExpr : BinExpr;
GEQExpr : BinExpr;
OrExpr : BinExpr;
AndExpr : BinExpr;

// Other expressions
CallExpr : Expr ::= Func:Expr Actual:Expr*;
Self : Expr ;
ListExpr : Expr ::= Expr* ;
IndexExpr : Expr ::= Base:Expr Index:Expr ;
NotExpr : Expr ::= Expr ;

// Constants
Constant : Expr ;
IntConstant : Constant ::= <Value:Integer> ;
StringConstant : Constant ::= <Value:String> ;

// Access
Access : Expr ::= IdUse ;
MemberAccess : Expr ::= Expr <ID> ;
QualifiedAccess : Expr ::= PackagePathFragment* ;

// Statements
abstract Stmt;
VarDeclStmt : Stmt ::= VarDecl ;
ExprStmt : Stmt ::= Expr ;
AssignStmt : Stmt ::= LValue:Expr RValue:Expr ;
BlockStmt : Stmt ::= Stmt* ;
IfStmt : Stmt ::= Cond:Expr Then:Stmt Else:Stmt ;
ForStmt : Stmt ::= Iterator:IdUse Rang:Expr Body:Stmt ;
WhileStmt : Stmt ::= Cond:Expr Body:Stmt ;
ReturnStmt : Stmt ::= Expr ;
AssertStmt : Expr ::= Expr <Message:String> ;
SkipStmt : Stmt;

// Identifiers
IdUse ::= <ID> ;
IdDecl ::= <ID> ;
