import lang.ir.*;

aspect IRGenExpr {
	public class TranslationResult {
		private ArrayList<IRVar> variables;
		private ArrayList<IRInsn> instructions;

		public TranslationResult() {
			variables = new ArrayList<>();
			instructions = new ArrayList<>();
		}

		public TranslationResult add(IRVar var) {
			variables.add(var);
			return this;
		}

		public TranslationResult add(IRInsn insn) {
			instructions.add(insn);
			return this;
		}

		public void append(TranslationResult other) {
			variables.addAll(other.variables);
			instructions.addAll(other.instructions);
		}
	}

	public enum VariableScope {
		LOCAL,
		GLOBAL,
		MEMBER
	}

	inh VariableScope VarDecl.getScope();
	eq Program.getDecl().getScope() = VariableScope.GLOBAL;
	eq FunDecl.getFormal().getScope() = VariableScope.LOCAL;
	eq VarDeclStmt.getVarDecl().getScope() = VariableScope.LOCAL;
	eq VarDeclElt.getVarDecl().getScope() = VariableScope.MEMBER;


	syn IRVar Expr.getIRVar() {
		int uid = getUID();
		return new IRVar(new IRName("$" + uid), type().genIR());
	}

	syn IRVarRef Expr.getIRVarRef() {
		return new IRVarRef(getIRVar());
	}

	syn TranslationResult Expr.genIR() = null;

	// IntConstant
	eq IntConstant.genIR() {
		TranslationResult tr = new TranslationResult();
		tr.add(getIRVar());
		tr.add(new IRConstantInsn().setDst(getIRVarRef()).setSrc(new IRInteger(getValue())));
		return tr;
	}

	// StringConstant
	eq StringConstant.genIR() {
		TranslationResult tr = new TranslationResult();
		tr.add(getIRVar());
		tr.add(new IRConstantInsn().setDst(getIRVarRef()).setSrc(new IRString(getValue())));
		return tr;
	}

	// Access
	syn IRInsn Decl.genAccess(IRVarRef dstVar) = null;
	eq VarDecl.genAccess(IRVarRef dstVar) {
		switch (getScope()) {
		default:
		case MEMBER:
			throw new NotYetImplementedError("Missing implementation for member accesses");
		case LOCAL:
			return new IRCopyInsn(dstVar, new IRVarRef(genIR()));
		}
	}

	eq Access.genIR() {
		// this can be a local variable load, global variable load or member access
		IdDecl idDecl = getIdUse().lookup();
		VarDecl d = (VarDecl) idDecl.getDecl();
		TranslationResult tr = new TranslationResult();
		switch (d.getScope()) {
		default:
		case MEMBER:
			throw new NotYetImplementedError("Missing implementation for member accesses");
		case LOCAL:
			tr.add(new IRCopyInsn(getIRVarRef(), new IRVarRef(d.genIR())));
			break;
		case GLOBAL:
			tr.add(new IRLoadStaticInsn().setDst(getIRVarRef()).setSrc(getIRVarRef()));
			break;
		}
		tr.add(getIRVar());
		return tr;
	}

	syn IRFunRef Expr.getCalledFunction() = null;
	eq Access.getCalledFunction() {
		IdDecl dd = getIdUse().lookup();
		// We have to bite the bullet and do the cast here. This
		// is translator code and the type hierarchy in the AST does not neatly
		// overlap to the hierarchy in the IR. This is to say that the diagram
		// below does not commute (where the down-arrow means translation)
		//   ASTType1   <:    ASTType2
		//     |                 |
		//     v                 v
		//   IRType1    <:    IRType2
		return new IRFunRef(((FunDecl)dd.getDecl()).genIR());
	}

	public static TranslationResult CallExpr.makeCall(IRFunRef target,
													  IRVar dstVar,
													  Expr ... actuals) {
		TranslationResult tr = new TranslationResult();
		IRCallInsn call = new IRCallInsn().setDst(new IRVarRef(dstVar));
		call.setIRFunRef(target);
		for (Expr e : actuals) {
			tr.append(e.genIR());
			call.addArg(e.getIRVarRef());
		}
		tr.add(call);
		tr.add(dstVar);
		return tr;
	}

	eq CallExpr.genIR() {
		TranslationResult tr = new TranslationResult();
		Expr fun = getFunc();
		IRFunRef funCallTarget = fun.getCalledFunction();
		if (funCallTarget != null) {
			IRCallInsn call = new IRCallInsn().setDst(getIRVarRef());
			call.setIRFunRef(funCallTarget);
			for (Expr e : getActuals()) {
				tr.append(e.genIR());
				call.addArg(e.getIRVarRef());
			}
			tr.add(getIRVar());
			tr.add(call);
		} else {
			throw new NotYetImplementedError("Method calls are not implemented");
		}
		return tr;
	}

	public IRVarRef Expr.genCode(IRFunctionCtx ctx) { throw new NotYetImplementedError("Can't translate expression.");}

	public IRVarRef CallExpr.genCode(IRFunctionCtx ctx) {
		Expr fun = getFunc();
		IRFunRef funCallTarget = fun.getCalledFunction();
		IRVarRef r = ctx.getTempIRVar(this);
		if (funCallTarget != null) {
			IRCallInsn call = new IRCallInsn().setDst(r);
			call.setIRFunRef(funCallTarget);
			for (Expr e : getActuals()) {
				e.genCode(ctx);
				call.addArg(ctx.getTempIRVar(e));
			}
			ctx.addInsn(call);
		} else {
			throw new NotYetImplementedError("Method calls are not implemented");
		}
		return r;
	}

	public IRVarRef Access.genCode(IRFunctionCtx ctx) {
		// this can be a local variable load, global variable load or member access
		IdDecl idDecl = getIdUse().lookup();
		VarDecl d = (VarDecl) idDecl.getDecl();
		IRVarRef r;
		switch (d.getScope()) {
		default:
		case MEMBER:
			throw new NotYetImplementedError("Missing implementation for member accesses");
		case LOCAL:
			r = ctx.getIRVarRef(d);
			break;
		case GLOBAL:
			r = new IRVarRef(d.genIR());
			break;
		}
		return r;
	}

}
