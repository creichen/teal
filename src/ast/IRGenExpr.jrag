import lang.ir.*;

aspect IRGenExpr {
	public enum VariableScope {
		LOCAL,
		GLOBAL,
		MEMBER
	}

	/*Warning at /work/projects/attol/src/ast/IRGenExpr.jrag:10: missing inherited equation for attribute getScope in class Decl when being child of Program (path: Program->Decl), and in class VarDecl when being child of ClassDecl (path: Program->ClassDecl->VarDecl), QualifierDecl (path: Program->QualifierDecl->VarDecl), ForStmt (path: Program->TypeDecl->FunDeclElt->FunDecl->ForStmt->VarDecl)


	 */

	inh VariableScope Decl.getScope();
	eq Program.getDecl().getScope() = VariableScope.GLOBAL;
	eq Program.getBuiltinDecl().getScope() = VariableScope.GLOBAL;
	eq FunDecl.getFormal().getScope() = VariableScope.LOCAL;
	eq VarDeclStmt.getVarDecl().getScope() = VariableScope.LOCAL;
	eq ForStmt.getIterator().getScope() = VariableScope.LOCAL;

	eq VarDeclElt.getVarDecl().getScope() = VariableScope.MEMBER;
	eq FunDeclElt.getFunDecl().getScope() = VariableScope.MEMBER;
	eq ClassDecl.getFunFormal().getScope() = VariableScope.MEMBER;
	eq QualifierDecl.getFunFormal().getScope() = VariableScope.MEMBER;
	eq TypeDecl.getTypeFormal().getScope() = VariableScope.MEMBER;

	syn IRVar Expr.getIRVar() {
		int uid = getUID();
		return new IRVar(new IRName("$" + uid), type().genIRTypeRef());
	}

	syn IRVarRef Expr.getIRVarRef() {
		return new IRVarRef(getIRVar());
	}

	syn IRFunRef Expr.getCalledFunction() = null;
	eq Access.getCalledFunction() {
		IdDecl dd = getIdUse().lookup();
		// We have to bite the bullet and do the cast here. This
		// is translator code and the type hierarchy in the AST does not neatly
		// overlap to the hierarchy in the IR. This is to say that the diagram
		// below does not commute (where the down-arrow means translation)
		//   ASTType1   <:    ASTType2
		//     |                 |
		//     v                 v
		//   IRType1    <:    IRType2
		return new IRFunRef(((FunDecl)dd.getDecl()).genIR());
	}

	public IRVarRef Expr.genCode(IRFunctionCtx ctx) {
		throw new NotYetImplementedError("Can't translate expression " + this.getClass());
	}

	syn String BinExpr.builtin();
	eq AddExpr.builtin() = BuiltinNames.INT_ADD;
	eq SubExpr.builtin() = BuiltinNames.INT_SUB;
	eq MulExpr.builtin() = BuiltinNames.INT_MUL;
	eq DivExpr.builtin() = BuiltinNames.INT_DIV;
	eq ModExpr.builtin() = BuiltinNames.INT_MOD;
	eq EQExpr.builtin() = BuiltinNames.ANY_EQ;
	eq NEQExpr.builtin() = BuiltinNames.ANY_NEQ;
	eq LTExpr.builtin() = BuiltinNames.INT_LT;
	eq GTExpr.builtin() = BuiltinNames.INT_GT;
	eq LEQExpr.builtin() = BuiltinNames.INT_LEQ;
	eq GEQExpr.builtin() = BuiltinNames.INT_GEQ;
	eq OrExpr.builtin() = BuiltinNames.INT_OR;
	eq AndExpr.builtin() = BuiltinNames.INT_AND;

	public IRVarRef BinExpr.genCode(IRFunctionCtx ctx) {
		IdDecl dd = lookup(builtin());
		IRFunRef builtinFunc = new IRFunRef(((FunDecl)dd.getDecl()).genIR());
		IRVarRef r = ctx.getTempIRVar(this);

		IRCallInsn call = new IRCallInsn().setDst(r).setIRFunRef(builtinFunc);
		IRVarRef left = getLeft().genCode(ctx);
		IRVarRef right = getRight().genCode(ctx);
		call.addArg(left).addArg(right);

		ctx.addInsn(call);

		return r;
	}

	public IRVarRef CallExpr.genCode(IRFunctionCtx ctx) {
		IdUse fun = getIdUse();
		FunDecl fd = (FunDecl) fun.lookup().getDecl();
		IRFunRef funCallTarget = new IRFunRef(fd.genIR());
		IRVarRef r = ctx.getTempIRVar(this);
		if (fd.getScope() == VariableScope.GLOBAL) {
			IRCallInsn call = new IRCallInsn().setDst(r);
			call.setIRFunRef(funCallTarget);
			for (Expr e : getActuals()) {
				IRVarRef arg = e.genCode(ctx);
				call.addArg(arg);
			}
			ctx.addInsn(call);
		} else {
			assert fd.getScope() == VariableScope.MEMBER;
			IRVar selfVar = ctx.getFreshTempIRVar(this);
			IRSelfInsn self = new IRSelfInsn().setDst(new IRVarRef(selfVar));
			ctx.addInsn(self);

			IRDispatchInsn dispatch = new IRDispatchInsn().setDst(r);
			dispatch.setIRFunRef(funCallTarget);
			dispatch.setBase(new IRVarRef(selfVar));
			for (Expr e : getActuals()) {
				IRVarRef arg = e.genCode(ctx);
				dispatch.addArg(arg);
			}
			ctx.addInsn(dispatch);
		}
		return r;
	}

	public IRVarRef DispatchExpr.genCode(IRFunctionCtx ctx) {
		Expr base = getExpr();
		TypeDefinition type = base.type();
		if (type == null)
			throw new RuntimeException("Can't generate dispatch from unknown base type, " + this + ".");
		IdDecl memberIdDecl = type.memberLookup(getID());
		if (memberIdDecl == null)
			throw new RuntimeException("Can't generate dispatch to unknown member, " + this + ".");
		Decl memberDecl = memberIdDecl.getDecl();
		if (!(memberDecl instanceof FunDecl))
			throw new RuntimeException("Can't call a member that is not a method, " + this + ".");
		IRVarRef tmp = ctx.getTempIRVar(this);
		IRDispatchInsn dispatch = new IRDispatchInsn()
			.setBase(base.genCode(ctx))
			.setIRFunRef(new IRFunRef(((FunDecl) memberDecl).genIR()))
			.setDst(tmp);
		for (Expr arg : getActuals()) {
			IRVarRef r = arg.genCode(ctx);
			dispatch.addArg(r);
		}
		ctx.addInsn(dispatch);
		return tmp;
	}

	public IRVarRef NewExpr.genCode(IRFunctionCtx ctx) {
		// allocate storage for the object
		IRVarRef dst = ctx.getTempIRVar(this);
		IRNewInsn newInsn = new IRNewInsn().setDst(dst)
			.setIRTypeRef(getType().genIR());
		ctx.addInsn(newInsn);

		// call the constructor to initialize the object
		IRDispatchInsn dispatch = new IRDispatchInsn()
			.setDst(new IRVarRef(ctx.getFreshTempIRVar(this)) /*unused*/)
			.setBase(ctx.getTempIRVar(this));
		IRTypeRef irType = getType().genIR();

		// TODO: ensure that new is called only on classes
		IRClass klass = (IRClass) ((IRTypeInstanceRef) irType).getIRType();
		IRFunction constructor = klass.getConstructor();
		dispatch.setIRFunRef(new IRFunRef(constructor));
		for (Expr arg : getActuals()) {
			IRVarRef r = arg.genCode(ctx);
			dispatch.addArg(r);
		}
		ctx.addInsn(dispatch);

		// return a reference to the allocated storage
		return dst;
	}

	public void Expr.genAssignment(IRVarRef rhs, IRFunctionCtx ctx) { throw new RuntimeException(getClass() + " not allowed as LValue."); }

	public void MemberAccess.genAssignment(IRVarRef rhs, IRFunctionCtx ctx) {
		Expr base = getExpr();
		TypeDefinition type = base.type();
		Decl memberDecl = type.memberLookup(getID()).getDecl();
		if (!(memberDecl instanceof VarDecl)) {
			super.genAssignment(rhs, ctx);
		}

		ctx.addInsn(new IRStoreInsn().setBase(base.genCode(ctx))
					.setField(new IRVarRef(((VarDecl)memberDecl).genIR()))
					.setSrc(rhs));
	}

	public IRVarRef MemberAccess.genCode(IRFunctionCtx ctx) {
		Expr base = getExpr();
		TypeDefinition type = base.type();
		Decl memberDecl = type.memberLookup(getID()).getDecl();
		if (!(memberDecl instanceof VarDecl))
			throw new RuntimeException("Can't load a member that is not a field, " + this + ".");
		IRVarRef tmp = ctx.getTempIRVar(this);
		ctx.addInsn(new IRLoadInsn().setBase(base.genCode(ctx))
					.setField(new IRVarRef(((VarDecl) memberDecl).genIR()))
					.setDst(tmp));
		return tmp;
	}

	public void Access.genAssignment(IRVarRef rhs, IRFunctionCtx ctx) {
		IdDecl idDecl = getIdUse().lookup();
		VarDecl d = (VarDecl) idDecl.getDecl();
		switch (d.getScope()) {
		case MEMBER:
			ctx.addInsn(new IRSelfInsn().setDst(ctx.getTempIRVar(this)));
			ctx.addInsn(new IRStoreInsn().setBase(ctx.getTempIRVar(this))
						.setField(new IRVarRef(d.genIR()))
						.setSrc(rhs));
		case LOCAL:
		case GLOBAL:
			IRVarRef dst = ctx.getIRVarRef(d);
			ctx.addInsn(new IRCopyInsn(dst, rhs));
		}
	}

	public IRVarRef TypedExpr.genCode(IRFunctionCtx ctx) {
		// TODO: generate an assertion too
		return getExpr().genCode(ctx);
	}

	public IRVarRef Access.genCode(IRFunctionCtx ctx) {
		// this can be a local variable load, global variable load or member access
		IdDecl idDecl = getIdUse().lookup();
		VarDecl d = (VarDecl) idDecl.getDecl();
		IRVarRef r;
		switch (d.getScope()) {
		default:
		case MEMBER:
			IRVar tmp = ctx.getFreshTempIRVar(this);
			ctx.addInsn(new IRSelfInsn().setDst(new IRVarRef(tmp)));
			ctx.addInsn(new IRLoadInsn().setBase(new IRVarRef(tmp))
						.setField(new IRVarRef(d.genIR()))
						.setDst(ctx.getTempIRVar(this)));
			r = ctx.getTempIRVar(this);
			break;
		case LOCAL:
			r = ctx.getIRVarRef(d);
			break;
		case GLOBAL:
			r = new IRVarRef(d.genIR());
			break;
		}
		return r;
	}

	public IRVarRef IntConstant.genCode(IRFunctionCtx ctx) {
		IRVarRef r = ctx.getTempIRVar(this);
		ctx.addInsn(new IRConstantInsn(r, new IRInteger(getValue())));
		return r;
	}

	public IRVarRef StringConstant.genCode(IRFunctionCtx ctx) {
		IRVarRef r = ctx.getTempIRVar(this);
		ctx.addInsn(new IRConstantInsn(r, new IRString(getValue())));
		return r;
	}
}
