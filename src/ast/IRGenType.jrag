aspect IRGenType {
	syn IRType TypeDecl.genIR() {
		throw new NotYetImplementedError("Translation of types not fully implemented");
	}

	syn IRTypeFormal TypeVarDecl.genIR() {
		return new IRTypeFormal(new IRName(getIdDecl().getID()));
	}

	syn IRVar VarDeclElt.genIR() {
		return getVarDecl().genIR();
	}

	syn IRFunction FunDeclElt.genIR() {
		return getFunDecl().genIR();
	}

	public IRFunction ClassDecl.makeConstructor() {
		IRFunction init = new IRFunction();
		init.setIRName(new IRName("__init"));

		// build the return type
		init.setIRTypeRef(new IRAnyTypeRef());

		// formal param types
		lang.ir.List<IRTypeRef> irTypes = new lang.ir.List<>();
		for (VarDecl d : getFunFormals()) {
			irTypes.add(d.type().genIRTypeRef());
		}
		init.setParamTypeList(irTypes);
		// extract the arguments
		IRFunctionCtx fctx = new IRFunctionCtx(init);
		fctx.startBB();
		for (int i = 0; i < getNumFunFormal(); ++i) {
			VarDecl d = getFunFormal(i);
			// extract the argument
			IRArgInsn iarg = new IRArgInsn(fctx.getIRVarRef(d), i);
			fctx.addInsn(iarg);
			// copy the argument to the member variable
			IRVar selfVar = fctx.getFreshTempIRVar(new IRAnyTypeRef());
			IRSelfInsn self = new IRSelfInsn().setDst(new IRVarRef(selfVar));
			fctx.addInsn(self);
			IRStoreInsn store = new IRStoreInsn().setBase(new IRVarRef(selfVar))
				.setField(new IRVarRef(d.genIR())).setSrc(fctx.getIRVarRef(d));
			fctx.addInsn(store);
		}
		// now add any initializer code
		for (StructElt e : getStructElts()) {
			if (e instanceof VarDeclElt) {
				VarDeclElt d = (VarDeclElt) e;
				d.getVarDecl().genCode(fctx);
			} else if (e instanceof StmtElt) {
				((StmtElt) e).getStmt().genCode(fctx);
			}
		}
		// return null
		if (fctx.getCurrentBB().getIRCodeExit() == null) {
			IRVar v = fctx.getFreshTempIRVar(new IRAnyTypeRef());
			fctx.addInsn(new IRConstantInsn().setDst(new IRVarRef(v))
										.setSrc(new IRNull()));
			fctx.getCurrentBB().setIRCodeExit(new IRReturn(new IRVarRef(v)));
		}
		// done
		return init;
	}

	eq ClassDecl.genIR() {
		// class with a name
		IRClass klass = new IRClass().setIRName(new IRName(getIdDecl().getID()));
		// set formal type parameters
		for (TypeVarDecl d : getTypeFormals()) {
			klass.addIRTypeFormal(d.genIR());
		}
		// set supertypes
		for (Type t : getSuperTypes()) {
			klass.addSuper(t.genIR());
		}
		// set the fields
		for (StructElt e : getStructElts()) {
			if (e instanceof VarDeclElt) {
				klass.addIRVar(((VarDeclElt)e).genIR());
			}
		}
		// add the class argument parameters as fields
		for (VarDecl d : getFunFormals()) {
			klass.addIRVar(d.genIR());
		}

		// build the constructor, which contains initializers for all the fields
		IRFunction init = makeConstructor();
		klass.setConstructor(init);
		// build the methods
		for (StructElt e : getStructElts()) {
			if (e instanceof FunDeclElt) {
				FunDecl fd = ((FunDeclElt) e).getFunDecl();
				IRFunction f = fd.genIR();
				fd.genCode(new IRFunctionCtx(f));
				klass.addIRFunction(f);
			}
		}

		return klass;
	}

	public IRTypeRef Decl.genIRTypeRef() {
		return null;
	}
	// syn IRTypeRef TypeDefinition.genIRTypeRef() = null;
	@Override public IRTypeRef TypeVarDecl.genIRTypeRef() {
		return new IRTypeFormalRef(genIR());
	}

	@Override public IRTypeRef TypeDecl.genIRTypeRef() {
		return new IRTypeInstanceRef().setIRType(genIR());
	}

	public IRTypeRef Type.genIR() {
		Decl d = getIdUse().lookup().getDecl();
		if (d instanceof TypeVarDecl) {
			return d.genIRTypeRef();
		} else if (d instanceof TypeDecl) {
			IRTypeInstanceRef t = (IRTypeInstanceRef) ((TypeDecl) d).genIRTypeRef();
			for (Type actual : getActuals()) {
				t.addTypeActual(actual.genIR());
			}
			return t;
			// TODO: add qualifiers here
		} else {
			throw new RuntimeException("Can't generate a type reference to something that is not a type, " + d + ".");
		}
    }
}
