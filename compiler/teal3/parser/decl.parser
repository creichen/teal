Decl decl = var_decl
          | fun_decl
          | type_decl
          | class_decl
          | qualifier_decl
          ;

VarDecl var_id_decl = ID type_opt? {: return new VarDecl(new IdDecl(ID), type_opt, new Opt()); :}
                    ;

VarDecl var_decl = VAR var_id_decl SEMICOLON {: return var_id_decl; :}
                 | VAR var_id_decl ASSIGN expr SEMICOLON {: var_id_decl.setInitializerOpt(new Opt(expr)); return var_id_decl; :}
                 ;

FunDecl fun_decl = concrete_fun_decl
                 | abstract_fun_decl
                 ;

Type type_opt = COLON type {: return type; :}
	      ;

FunDecl concrete_fun_decl = FUN ID LPAREN fun_formals RPAREN type_opt? EQ stmt {: return new FunDecl(new IdDecl(ID), type_opt, fun_formals, new Opt(stmt)); :}
                          ;

FunDecl abstract_fun_decl = FUN ID LPAREN fun_formals RPAREN type_opt? SEMICOLON {: return new FunDecl(new IdDecl(ID), type_opt, fun_formals, new Opt()); :}
                          ;

List fun_formals = /* empty */ {: return new List(); :}
		 | fun_formal_list
		 ;

List fun_formals_opt = /* empty */ {: return new List(); :}
                     | LPAREN fun_formal_list RPAREN {: return fun_formal_list; :}
                     ;

List fun_formal_list = fun_formal {: return new List(fun_formal); :}
                     | fun_formal_list COMMA fun_formal {: return fun_formal_list.add(fun_formal); :}
                     ;

VarDecl fun_formal = var_id_decl
                   ;


Type type_no_qual = ID type_actuals {: return new Type(new IdUse(ID), type_actuals, new List()); :}
Type type = type_no_qual
          | type_qualifier type {: return type.addTypeQualifier(type_qualifier); :}
          ;

TypeQualifier type_qualifier = ID type_actuals fun_actuals {: return new TypeQualifier(new IdUse(ID), type_actuals, fun_actuals); :}
                             ;

List type_actuals = /* empty */ {: return new List(); :}
                  | LBRACK RBRACK {: return new List(); :}
                  | LBRACK type_actual_list RBRACK {: return type_actual_list; :}
                  ;

List type_actual_list = type {: return new List(type); :}
                      | type_actual_list COMMA type {: return type_actual_list.add(type); :}
                      ;

List fun_actuals = /* empty */ {: return new List(); :}
                 | LPAREN RPAREN {: return new List(); :}
                 | LPAREN fun_actual_list RPAREN {: return fun_actual_list; :}
                 ;

List fun_actual_list = expr {: return new List(expr); :}
                     | fun_actual_list COMMA expr {: return fun_actual_list.add(expr); :}
                     ;


List type_formals = /* empty */ {: return new List(); :}
                  | LBRACK RBRACK {: return new List(); :}
                  | LBRACK type_formal_list RBRACK {: return type_formal_list; :}
                  ;

List type_formal_list = type_var_decl {: return new List(type_var_decl); :}
                      | type_formal_list COMMA type_var_decl {: return type_formal_list.add(type_var_decl); :}
                      ;


TypeVarDecl type_var_decl = ID {: return new TypeVarDecl(new IdDecl(ID)); :}
                          ;

TypeDecl type_decl = TYPE ID type_formals EQ type SEMICOLON
                        {:return new TypeDecl(new IdDecl(ID), type_formals, new List().add(type), new List()); :}
                   | TYPE ID type_formals SUBTYPE type_actual_list EQ struct_decl
                        {: return new TypeDecl(new IdDecl(ID), type_formals, type_actual_list, struct_decl); :}
                   | TYPE ID type_formals EQ struct_decl
                        {: return new TypeDecl(new IdDecl(ID), type_formals, new List(), struct_decl); :}
                   ;

List struct_decl = LBRACE struct_elt* RBRACE {: return struct_elt; :}
                 ;

StructElt struct_elt = var_decl {: return new VarDeclElt(var_decl); :}
                     | fun_decl {: return new FunDeclElt(fun_decl); :}
                     | expr_stmt {: return new StmtElt(expr_stmt); :}
                     | assign_stmt {: return new StmtElt(assign_stmt); :}
                     ;

ClassDecl class_decl = CLASS ID type_formals fun_formals_opt EQ struct_decl
                           {: return new ClassDecl(new IdDecl(ID), type_formals, new List(), struct_decl, fun_formals_opt); :}
                     | CLASS ID type_formals fun_formals_opt SUBTYPE type_actual_list EQ struct_decl
                           {: return new ClassDecl(new IdDecl(ID), type_formals, type_actual_list, struct_decl, fun_formals_opt); :}
                     ;

QualifierDecl qualifier_decl = QUALIFIER ID type_formals fun_formals_opt EQ struct_decl
                                    {: return new QualifierDecl(new IdDecl(ID), type_formals,
                                                                new List(), struct_decl, fun_formals_opt); :}
                             | QUALIFIER ID type_formals fun_formals_opt SUBTYPE type_actual_list EQ struct_decl
                                    {: return new QualifierDecl(new IdDecl(ID), type_formals,
                                                                type_actual_list, struct_decl, fun_formals_opt); :}
                             ;

List fun_actual_list_maybe_empty = /* empty */ {: return new List(); :}
                                 | fun_actual_list
                                 ;


