aspect SemanticCheck {
	class SemanticError implements CompilerError {
		SrcLoc loc;
		String msg;

		public SemanticError(SrcLoc loc, String msg) {
			this.loc = loc;
			this.msg = msg;
		}

		@Override public String report() {
			return loc.pretty() + ": " + msg;
		}

		@Override public int getStartLoc() {
			return loc.getStartLoc();
		}
	}

	class LValueError extends SemanticError {
		public LValueError(SrcLoc loc) {
			super(loc, "Illegal target extends for assignment.");
		}
	}

	// nothing here
	coll ArrayList<CompilerError> Program.semanticErrors() [new ArrayList<CompilerError>()];

	syn boolean Expr.isLValue() = false;
	eq Access.isLValue() = true;
	eq IndexExpr.isLValue() = true;
	eq TypedExpr.isLValue() = getExpr().isLValue();

	AssignStmt contributes new LValueError(getLValue().getSrcLoc()) when !getLValue().isLValue() to Program.semanticErrors();

	VarDecl contributes new SemanticError(getSrcLoc(), "Global variable does not allow explicit initialization. Its initial value is always null.")
		when hasInitializer() && getScope() == VariableScope.GLOBAL to Program.semanticErrors();
}
