import lang.common.Report;

/**
 * Incomplete type analysis
 *
 */
aspect TypeAnalysis {
	/**
	 * Type error report
	 */
	public class TypeError extends Report {
		/**
		 * Constructs a TypeError
		 *
		 * You can use <tt>withExplanation</tt> to change the description
		 *
		 * @param location AST node with the type error
		 * @param t1 String representation of th
		 */
		public TypeError(ASTNode location) {
			// Tag as WARN for yellow squiggly lines
			super("type", Report.CodeProber.WARN, location);
		}
	}

	/**
	 * One type constructor for each of the four predefined types from Teal-0
	 *
	 * Since Int, String etc. are AST nodes, they are not equal to each other.
	 * We represent them by enum values that we can easily check for equality.
	 */
	enum TyCon {
		ANY	{ public String toString() { return "any"; } },
		INT	{ public String toString() { return "int"; } },
		STRING	{ public String toString() { return "string"; } },
		ARRAY	{ public String toString() { return "array"; } }
	}

	syn TyCon Type.tyCon();
	eq AnyType.tyCon()    = TyCon.ANY;
	eq IntType.tyCon()    = TyCon.INT;
	eq StringType.tyCon() = TyCon.STRING;
	eq ArrayType.tyCon()  = TyCon.ARRAY;

	/**
	 * Interpret the type of literal values and explicit type annotations.
	 *
	 * @return Either the precise type of the expression if that type is obvious
	 * purely by looking at the AST node, or <tt>null</tt>.
	 */
	syn Type Expr.implicitType() = null;
	eq IntConstant.implicitType() = new IntType();
	eq StringConstant.implicitType() = new StringType();
	eq TypedExpr.implicitType() {
		return getDeclaredType();
	}

	/**
	 * Infers the type of the expression.
	 *
	 * @return The expression's type, or AnyType if the expression's type
	 * is unknown or contradictory.
	 */
	syn Type Expr.type() {
	    Type ty = this.implicitType();
	    if (ty == null) {
		return new AnyType();
	    }
	    return ty;
	}

	// The type of this variable, as far as we can tell (without trying very hard); never null
	syn Type VarDecl.variableType() {
		if (hasDeclaredType()) {
			return getDeclaredType();
		}
		if (hasInitializer()) {
			return getInitializer().type();
		}
		return new AnyType();
	}

	// The return type; never null
	syn Type FunDecl.returnType() {
		if (hasDeclaredReturnType()) {
			return getDeclaredReturnType();
		}
		return new AnyType();
	}
}
